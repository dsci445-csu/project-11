---
title: "Predicting Soccer Match Outcomes"
author: "Theyab Alkhoori, Jasmine Moskowitz, Max Treusein"
date: "2025-12-02"
output: pdf_document
---

# Introduction
Around the world, soccer is a popular sport. Millions of people enjoy using each team's data to predict match outcomes. Our project aims to predict match results of the 2015 season. We will predict the 2015 season using the statistics from the 2010 to 2014 seasons, then compare our predictions with the actual outcomes. In the end we hope to know if the home team wins, ties, or loses and well as the number of goals scored during the game. Once complete we can then compare our results with the actual results of the game.

# References 
We plan to execute our desired tasks by using the **European Soccer Database** from Kaggle (https://www.kaggle.com/datasets/hugomathien/soccer/data). This source includes information from more than 25,000 games, more than 10,000 players, and eleven European nations. The data contains match statistics, results, and other information all contained in csv files. 
We will split the data into two parts: train and test. The training data will contain data from the season 2010 to 2014. The test data will contain data from the 2015 season. 

# Methods
## Task 1: Data Preparation
Our first task is to clean out the data from the csv files. We want to extract all the necessary data to make it easier to complete our tasks. 

## Task 2: Classification
Our second task is using classification methods to predict match outcomes (home win, tie, home loss)

## Task 3: Regression
Our third task is to predict the number of goals scored in a match. 

# Results

Task 1: If the home team wins, ties, or loses.

Task 2: The number of goals scored during a game.

We used the **European Soccer Database** from Kaggle, which includes 11 leagues, 10,000 players, and more than 25,000.

```{r}
library(tidymodels)
library(discrim)
library(ISLR)
library(ggplot2)
library(dplyr)
library(readr)
library(lubridate)
library(randomForest)
library(vip)

set.seed(445)

## Load raw data ----
match <- read.csv("Match.csv")
team <- read.csv("Team.csv")
team_attr <- read.csv("Team_Attributes.csv")

## Team-season attributes ----
team_attr |>
  mutate(
    date = as.Date(date),
    season = year(date)
  ) |>
  filter(season >= 2010, season <= 2015) |>
  select(-id, -date) |>
  group_by(team_api_id, season) |>
  summarise(
    across(where(is.numeric), ~ mean(.x, na.rm = TRUE)),
    .groups = "drop"
  ) -> team_season_attr

team |>
  select(team_api_id, team_long_name, team_short_name) |>
  right_join(team_season_attr, by = "team_api_id") -> team_season_attr

num_cols <- sapply(team_season_attr, is.numeric)

team_season_attr[num_cols] <- lapply(team_season_attr[num_cols], function(x) {
  if (all(is.na(x))) return(x)
  x[is.na(x)] <- mean(x, na.rm = TRUE)
  x
})

## Build match-level outcome and season ----
match |>
  mutate(
    date = as.Date(date),
    season = year(date),
    home_result = case_when(
      home_team_goal > away_team_goal ~ "Win",
      home_team_goal == away_team_goal ~ "Draw",
      home_team_goal < away_team_goal ~ "Loss"
    ),
    home_result = factor(home_result, levels = c("Win", "Draw", "Loss"))
  ) |>
  filter(season >= 2010, season <= 2015) |>
  select(
    match_api_id,
    season,
    date,
    home_team_api_id,
    away_team_api_id,
    home_team_goal,
    away_team_goal,
    home_result
  ) -> matches_base

## Home-team attributes ----
team_season_attr |>
  rename(
    home_team_api_id = team_api_id
  ) |>
  rename_with(
    ~ paste0("home_", .x),
    .cols = -c(home_team_api_id, season)
  ) -> home_attr

## Away-team attributes ----
team_season_attr |>
  rename(
    away_team_api_id = team_api_id
  ) |>
  rename_with(
    ~ paste0("away_", .x),
    .cols = -c(away_team_api_id, season)
  ) -> away_attr

## Join attributes onto matches ----
matches_base |>
  left_join(home_attr, by = c("season", "home_team_api_id")) |>
  left_join(away_attr, by = c("season", "away_team_api_id")) -> soccer_matches

## Final train / test splits ----
train_matches <- soccer_matches |> filter(season <= 2014)
test_matches  <- soccer_matches |> filter(season == 2015)

head(train_matches)
head(test_matches)

```

```{r}
# Prepare training and test data with predictors only
train_data <- train_matches |>
  mutate(
    buildUpPlaySpeed_diff        = home_buildUpPlaySpeed        - away_buildUpPlaySpeed,
    buildUpPlayPassing_diff      = home_buildUpPlayPassing      - away_buildUpPlayPassing,
    chanceCreationPassing_diff   = home_chanceCreationPassing   - away_chanceCreationPassing,
    chanceCreationCrossing_diff  = home_chanceCreationCrossing  - away_chanceCreationCrossing,
    chanceCreationShooting_diff  = home_chanceCreationShooting  - away_chanceCreationShooting,
    defencePressure_diff         = home_defencePressure         - away_defencePressure,
    defenceAggression_diff       = home_defenceAggression       - away_defenceAggression,
    defenceTeamWidth_diff        = home_defenceTeamWidth        - away_defenceTeamWidth,
    speed_shooting_int           = buildUpPlaySpeed_diff * chanceCreationShooting_diff,
    defence_press_agg_int        = defencePressure_diff * defenceAggression_diff
  ) |>
  select(
    home_result,
    buildUpPlaySpeed_diff,
    buildUpPlayPassing_diff,
    chanceCreationPassing_diff,
    chanceCreationCrossing_diff,
    chanceCreationShooting_diff,
    defencePressure_diff,
    defenceAggression_diff,
    defenceTeamWidth_diff,
    speed_shooting_int,
    defence_press_agg_int
  ) |>
  drop_na()

test_data <- test_matches |>
  mutate(
    buildUpPlaySpeed_diff        = home_buildUpPlaySpeed        - away_buildUpPlaySpeed,
    buildUpPlayPassing_diff      = home_buildUpPlayPassing      - away_buildUpPlayPassing,
    chanceCreationPassing_diff   = home_chanceCreationPassing   - away_chanceCreationPassing,
    chanceCreationCrossing_diff  = home_chanceCreationCrossing  - away_chanceCreationCrossing,
    chanceCreationShooting_diff  = home_chanceCreationShooting  - away_chanceCreationShooting,
    defencePressure_diff         = home_defencePressure         - away_defencePressure,
    defenceAggression_diff       = home_defenceAggression       - away_defenceAggression,
    defenceTeamWidth_diff        = home_defenceTeamWidth        - away_defenceTeamWidth,
    speed_shooting_int           = buildUpPlaySpeed_diff * chanceCreationShooting_diff,
    defence_press_agg_int        = defencePressure_diff * defenceAggression_diff
  ) |>
  select(
    home_result,
    buildUpPlaySpeed_diff,
    buildUpPlayPassing_diff,
    chanceCreationPassing_diff,
    chanceCreationCrossing_diff,
    chanceCreationShooting_diff,
    defencePressure_diff,
    defenceAggression_diff,
    defenceTeamWidth_diff,
    speed_shooting_int,
    defence_press_agg_int
  )

## Drop predictors that are entirely NA ----
na_all_cols <- names(train_data)[sapply(train_data, function(x) all(is.na(x)))]

na_all_cols

train_data <- train_data |>
  select(-all_of(na_all_cols))

test_data <- test_data |>
  select(-all_of(na_all_cols))

## Also drop any remaining rows with NA in predictors or outcome
train_data <- train_data |>
  drop_na()

test_data <- test_data |>
  drop_na()
```

```{r}
## Logistic Regression ----

# Specify multinomial logistic regression
logistic_spec <- multinom_reg(mode = "classification") |>
  set_engine("nnet")

# Fit model on training data
logistic_spec |>
  fit(home_result ~ ., data = train_data) -> m0.fit

# Training confusion matrix
cat("=== MULTINOMIAL LOGISTIC RESULTS ===\n")

m0.fit |>
  augment(new_data = train_data) |>
  conf_mat(truth = home_result, estimate = .pred_class)

# Training error rate
m0.fit |>
  augment(new_data = train_data) |>
  accuracy(truth = home_result, estimate = .pred_class) |>
  mutate(error = 1 - .estimate) |>
  pull(error)

# Test confusion matrix and error rate
logistic_spec |>
  fit(home_result ~ ., data = train_data) |>
  augment(new_data = test_data) -> m0.test_res

m0.test_res |>
  conf_mat(truth = home_result, estimate = .pred_class)

m0.test_res |>
  accuracy(truth = home_result, estimate = .pred_class) |>
  mutate(error = 1 - .estimate) |>
  pull(error)
```

```{r}
### KNN ----

cat("=== KNN (K=1) RESULTS ===\n")

## K = 1
knn1_spec <- nearest_neighbor(mode = "classification", neighbors = 1)

knn1_spec |>
  fit(home_result ~ ., data = train_data) -> knn1.fit

knn1.fit |>
  augment(new_data = test_data) -> knn1.test_res

knn1.test_res |>
  conf_mat(truth = home_result, estimate = .pred_class)

knn1.test_res |>
  accuracy(truth = home_result, estimate = .pred_class) |>
  mutate(error = 1 - .estimate) |>
  pull(error)

## K = 3

cat("=== KNN (K=3) RESULTS ===\n")

knn3_spec <- nearest_neighbor(mode = "classification", neighbors = 3)

knn3_spec |>
  fit(home_result ~ ., data = train_data) -> knn3.fit

knn3.fit |>
  augment(new_data = test_data) -> knn3.test_res

knn3.test_res |>
  conf_mat(truth = home_result, estimate = .pred_class)

knn3.test_res |>
  accuracy(truth = home_result, estimate = .pred_class) |>
  mutate(error = 1 - .estimate) |>
  pull(error)


## K = 5

cat("=== KNN (K=5) RESULTS ===\n")

knn5_spec <- nearest_neighbor(mode = "classification", neighbors = 5)

knn5_spec |>
  fit(home_result ~ ., data = train_data) -> knn5.fit

knn5.fit |>
  augment(new_data = test_data) -> knn5.test_res

knn5.test_res |>
  conf_mat(truth = home_result, estimate = .pred_class)

knn5.test_res |>
  accuracy(truth = home_result, estimate = .pred_class) |>
  mutate(error = 1 - .estimate) |>
  pull(error)
```

```{r}
### Validation Set Approach ----

goals_train <- train_matches |>
  mutate(
    buildUpPlaySpeed_diff        = home_buildUpPlaySpeed        - away_buildUpPlaySpeed,
    buildUpPlayPassing_diff      = home_buildUpPlayPassing      - away_buildUpPlayPassing,
    chanceCreationPassing_diff   = home_chanceCreationPassing   - away_chanceCreationPassing,
    chanceCreationCrossing_diff  = home_chanceCreationCrossing  - away_chanceCreationCrossing,
    chanceCreationShooting_diff  = home_chanceCreationShooting  - away_chanceCreationShooting,
    defencePressure_diff         = home_defencePressure         - away_defencePressure,
    defenceAggression_diff       = home_defenceAggression       - away_defenceAggression,
    defenceTeamWidth_diff        = home_defenceTeamWidth        - away_defenceTeamWidth,
    speed_shooting_int           = buildUpPlaySpeed_diff * chanceCreationShooting_diff,
    defence_press_agg_int        = defencePressure_diff * defenceAggression_diff
  ) |>
  select(
    home_team_goal,
    buildUpPlaySpeed_diff,
    buildUpPlayPassing_diff,
    chanceCreationPassing_diff,
    chanceCreationCrossing_diff,
    chanceCreationShooting_diff,
    defencePressure_diff,
    defenceAggression_diff,
    defenceTeamWidth_diff,
    speed_shooting_int,
    defence_press_agg_int
  )

goals_test  <- test_matches |>
  mutate(
    buildUpPlaySpeed_diff        = home_buildUpPlaySpeed        - away_buildUpPlaySpeed,
    buildUpPlayPassing_diff      = home_buildUpPlayPassing      - away_buildUpPlayPassing,
    chanceCreationPassing_diff   = home_chanceCreationPassing   - away_chanceCreationPassing,
    chanceCreationCrossing_diff  = home_chanceCreationCrossing  - away_chanceCreationCrossing,
    chanceCreationShooting_diff  = home_chanceCreationShooting  - away_chanceCreationShooting,
    defencePressure_diff         = home_defencePressure         - away_defencePressure,
    defenceAggression_diff       = home_defenceAggression       - away_defenceAggression,
    defenceTeamWidth_diff        = home_defenceTeamWidth        - away_defenceTeamWidth,
    speed_shooting_int           = buildUpPlaySpeed_diff * chanceCreationShooting_diff,
    defence_press_agg_int        = defencePressure_diff * defenceAggression_diff
  ) |>
  select(
    home_team_goal,
    buildUpPlaySpeed_diff,
    buildUpPlayPassing_diff,
    chanceCreationPassing_diff,
    chanceCreationCrossing_diff,
    chanceCreationShooting_diff,
    defencePressure_diff,
    defenceAggression_diff,
    defenceTeamWidth_diff,
    speed_shooting_int,
    defence_press_agg_int
  )

## Drop predictors that are entirely NA ----
na_all_cols2 <- names(goals_train)[sapply(goals_train, function(x) all(is.na(x)))]

goals_train <- goals_train |>
  select(-all_of(na_all_cols2))

goals_test <- goals_test |>
  select(-all_of(na_all_cols2))

## Also drop any remaining rows with NA in predictors or outcome
goals_train <- goals_train |>
  drop_na()

goals_test <- goals_test |>
  drop_na()

## Prepare linear regression spec

linear_spec <- linear_reg()

## Base recipe: predict home_team_goal using the best predictors
linear_rec <- recipe(
  home_team_goal ~ ., data = goals_train)


## 4. Fit the linear model
linear_model <- workflow() |>
  add_model(linear_spec) |>
  add_recipe(linear_rec) |>
  fit(data = goals_train)

## Compute test MSE for linear model

linear_model |>
  augment(new_data = goals_test) |>
  mutate(resid2 = (.resid)^2) |>
  summarise(mse = mean(resid2, na.rm = TRUE)) |>
  mutate(model = "Linear Regression (Goals)") |>
  relocate(model)

## Actual vs Predicted: Linear Regression ----
linear_aug <- linear_model |>
  augment(new_data = goals_test)

linear_aug |>
  ggplot(aes(x = home_team_goal, y = .pred)) +
  geom_point(alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dashed", color = "red") +
  labs(
    title = "Linear Regression: Actual vs Predicted Home Goals (2015 Season)",
    x = "Actual Home Goals",
    y = "Predicted Home Goals"
  )

### Quadratic Model ----

## Add squared terms

quad_rec <- linear_rec |>
  step_mutate(
    buildUpPlaySpeed_diff2       = buildUpPlaySpeed_diff^2,
    buildUpPlayPassing_diff2     = buildUpPlayPassing_diff^2,
    chanceCreationPassing_diff2  = chanceCreationPassing_diff^2,
    chanceCreationCrossing_diff2 = chanceCreationCrossing_diff^2,
    chanceCreationShooting_diff2 = chanceCreationShooting_diff^2,
    defencePressure_diff2        = defencePressure_diff^2,
    defenceAggression_diff2      = defenceAggression_diff^2,
    defenceTeamWidth_diff2       = defenceTeamWidth_diff^2
  )

workflow() |>
  add_model(linear_spec) |>
  add_recipe(quad_rec) |>
  fit(data = goals_train) |>
  augment(new_data = goals_test) |>
  mutate(resid2 = (.resid)^2) |>
  summarise(mse = mean(resid2, na.rm = TRUE)) |>
  mutate(model = "Quadratic Regression (Goals)") |>
  relocate(model)

## Fit quadratic model for plotting ----
quad_model <- workflow() |>
  add_model(linear_spec) |>
  add_recipe(quad_rec) |>
  fit(data = goals_train)

quad_aug <- quad_model |>
  augment(new_data = goals_test)

quad_aug |>
  ggplot(aes(x = home_team_goal, y = .pred)) +
  geom_point(alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dashed", color = "red") +
  labs(
    title = "Quadratic Regression: Actual vs Predicted Home Goals (2015 Season)",
    x = "Actual Home Goals",
    y = "Predicted Home Goals"
  )


### Cubic Model ----

## Add cubic terms the same way

cubic_rec <- quad_rec |>
  step_mutate(
    buildUpPlaySpeed_diff3       = buildUpPlaySpeed_diff^3,
    buildUpPlayPassing_diff3     = buildUpPlayPassing_diff^3,
    chanceCreationPassing_diff3  = chanceCreationPassing_diff^3,
    chanceCreationCrossing_diff3 = chanceCreationCrossing_diff^3,
    chanceCreationShooting_diff3 = chanceCreationShooting_diff^3,
    defencePressure_diff3        = defencePressure_diff^3,
    defenceAggression_diff3      = defenceAggression_diff^3,
    defenceTeamWidth_diff3       = defenceTeamWidth_diff^3
  )

workflow() |>
  add_model(linear_spec) |>
  add_recipe(cubic_rec) |>
  fit(data = goals_train) |>
  augment(new_data = goals_test) |>
  mutate(resid2 = (.resid)^2) |>
  summarise(mse = mean(resid2, na.rm = TRUE)) |>
  mutate(model = "Cubic Regression (Goals)") |>
  relocate(model)

## Fit cubic model for plotting ----
cubic_model <- workflow() |>
  add_model(linear_spec) |>
  add_recipe(cubic_rec) |>
  fit(data = goals_train)

cubic_aug <- cubic_model |>
  augment(new_data = goals_test)

cubic_aug |>
  ggplot(aes(x = home_team_goal, y = .pred)) +
  geom_point(alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dashed", color = "red") +
  labs(
    title = "Cubic Regression: Actual vs Predicted Home Goals (2015 Season)",
    x = "Actual Home Goals",
    y = "Predicted Home Goals"
  )

```

```{r}
## Random Forest Regression ----

# Specification: random forest for regression on home goals
rf_spec <- rand_forest(mtry = sqrt(.cols())) |>
  set_engine("randomForest", importance = TRUE) |>
  set_mode("regression")

# Use the same predictors as the other regression models
# (goals_train has home_team_goal and all diff variables)
rf_wf <- workflow() |>
  add_model(rf_spec) |>
  add_formula(home_team_goal ~ .)

# Fit on training data
rf_fit <- rf_wf |>
  fit(data = goals_train)

# Variable importance plot
vip(rf_fit) +
  labs(title = "Random Forest Variable Importance (%IncMSE)")

# Predictions on test data
rf_fit |>
  predict(new_data = goals_test) |>
  bind_cols(goals_test) -> rf_test_res

# Test MSE for random forest regression
rf_test_res |>
  mutate(resid2 = (home_team_goal - .pred)^2) |>
  summarise(mse = mean(resid2))

# Actual vs Predicted plot for random forest regression
rf_test_res |>
  ggplot(aes(x = home_team_goal, y = .pred)) +
  geom_point(alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dashed", color = "red") +
  labs(
    title = "Random Forest: Actual vs Predicted Home Goals (2015 Season)",
    x = "Actual Home Goals",
    y = "Predicted Home Goals"
  )

```

Best Classification Model: K Nearest Neighbors - K = 3

For classification, out of the munti-nomial logistic regression model, and the K nearest neighbor model, the better of the two models was KNN. KNN performed the best with K = 3, which had an average accuracy of just over 63% on the test data. This is marginally better than the logistic model, which performed at average accuracy of about 54% on the test data. We also noticed that the logistic model never predicted a draw. This could be because the prediction uses argmax(p_win, p_draw, p_loss). If p_draw is never the largest, draw is never predicted, therefore with this model, the draw variable colapses. KNN adjusts for the non-linearity of the data, raising the test accuracy almost 10%.

Best Regression Model: Undetermined - all MSE around 1.6

The regression models proved to be a lot harder to get good accuracy. Each model, including the linear, quadratic, and cubic regression models, as well as the random forest regression model performed with an MSE around 1.6. This means the model predicted between plus or minus 1.6 of the true amount of goals scored, which is not very accurate considering most of the amount of goals scored by the home team in a game is between 0 and 3. Specifically, for the quadratic and cubic regression models, we could have squared and cubed different predictors to see if any of the terms alone follow a quadratic or cubic pattern, instead of squaring and cubing every term we used. For the random forest model, we can see the predictors with the most influence are defencePressure_diff and buildUpPlayPassing_diff. This means that the difference in defence pressure and difference in build up passing plays between the home and away team have the most influence in determining how many goals are scored. For the best performing model, we chose Random Forest Regression because the fitted regression line seems to be closest to actual trend of data, but its open to interpretation.
  
# Reflection (Things to Improve on):

To improve these models, we could have included more match-specific information like recent team form, last-5 goal totals, rolling averages of chances/shots, etc. could have reduced the modelâ€™s tendency to predict values near the mean.

Finally, we could have added player-level strength instead of only team ratings such as average overall rating of expected starters, attacking/defensive overall, or key-player availability. This could raise predictive power because goals depend heavily on who is actually on the field, not just team-level attributes.
